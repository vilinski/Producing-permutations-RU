#Получение перестановок

Перевод блогпоста Эрика Липперта про перестановки  [http://ericlippert.com/2013/04/15/producing-permutations-part-one/]

##Часть первая.

Одна из моих наиболее популярных статей 2010 года был мой пост 
о том, как вычислять декартово произведение любого числа последовательностей одного и того
же типа. 
То есть, у нас есть некоторые последовательности, скажем, `{10, 20, 30}` и `{200, 300, 4
00}`, и мы хотим получить последовательность всех возможных комбинаций:

```csharp
{ 
   {10, 200}, {10, 300}, {10, 400} 
   {20, 200}, {20, 300}, {20, 400}
   {30, 200}, {30, 300}, {30, 400} 
 } 

```
С этим связан вопрос, на который я не ответил: "Как получить все возможные перестановки последовательности?" 
Этот вопрос мы будем изучать в течение следующих нескольких эпизодов. 

Во-первых, мы должны дать определение "перестановке". 
Перестановка в нашем случае является возможным изменением порядка конечной последовательности уникальных элементов. 
Я не собираюсь рассматривать более сложныме перестановки. Например, как найти все последовательности, 
содержащие три синих носка, один красный носок и один зеленый, мы будем считать, что все носки являются уникальными.  Давайте предположим, что последовательность, которую мы переставляем содержит N елементов `{0, 1, 2, 3, .. n - 1}`.  Как мы вскоре увидим, если мы можем переставить элементы этой последовательности, то мы можем переставлять любую последовательность из N элементов. 

Сколько же существует перестановок размера N?  Мы могли бы их просто перечислить и попытаться найти что-то общее.  

Очевидным является, что существует только одна перестановка последовательности `{0}`, 
и нет никакого способа изменить её порядок.  

Есть два варианта перестановки последовательности из двух элементов: `{0, 1}` и `{1, 0}` . 

Их 3-х элементов?  `{0, 1, 2}, {0, 2, 1}, {1, 0, 2}, {1, 2, 0}, {2, 0, 1}, {2, 1, 0} `.  Шесть. 

Их 4-х элементов? `{0, 1, 2, 3}, {0, 1, 3, 2}, ... ` Это получается уже длинно... 

Давайте, вместо того чтобы их перечислять, применим математический подход. 

Для последовательности из N элементов, существует N различных возможности выбрать первый элемент.  
Этот первый элемент становится недоступным для выбора второго элемента.
Так что есть N-1 возможностей выбрать второй элемент, N-2 возможностей выбрать третий и так далее 
вплоть до последней и единственной возможности выбрать последний элемент N-(N-1) = 1.
Она полностью предопределяется предыдущими выборами.  Умножьте всё это вместе и получим N!
Который соответствует нашим результаты до сих пор, потому что 

+ 1! = 1, 
+ 2! = 2, 
+ 3! = 6. 

Подождите, одну последовательность мы забыли: Что из себя представляют все перестановки пустой последовательности, 
с 0 элементами, { } ?  
Очевидно, что существует только одна возможность перестановки пустой последовательности, 
которая тоже является пустой последовательностью.  И по соглашению, 0! = 1, так что наша теория пока в порядке.
Мы доказали, что имеется n! перестановок последовательности из N элементов. 

Итак, как же мы теперь можем вычислить все эти перестановки?
Есть несколько способов. 
Сейчас я собираюсь показать вам, как решить это, с помощью рекурсии.  
Как мы уже обсуждали много раз до этого, каждый рекурсивный алгоритм имеет одну и ту же структуру: 

Если случай простой, решаем его и возвращаем результат.
Сложную задачу разбиваем на конечное число простых задач. 
Решаем каждую из них рекурсивно. 
Объединяем решения простых задач в одно сложное решение и возвращаем результат.

У нас есть простой случай: мы знаем, что единственная перестановка нулевой последовательности является 
она сама. 

Теперь предположим, что у нас есть готовая последовательность всех перестановок размера 3, 
  
   `{
   {0, 1, 2},
   {0, 2, 1}
   {1, 0, 2},
   {1, 2, 0},
   {2, 0, 1}
   {2, 1, 0}
   }`
   
Как использовать её для получения последовательности размером 4?  
Ну, есть 6 перестановок в этой последовательности.  Мы знаем, что мы собираемся нужно придумать с 24 как-то.  
Интуиция говорит нам, что каждый из этих 6 должны быть в состоянии генерировать еще 4 последовательностей.  
А на самом деле она может: мы изменим каждой последовательности, вставив 3 перед первым элементом, 
перед вторым элементом, перед третьим элементом, или после третьего элемента: 
  {  
 {3, 0, 1, 2} 
 {0, 3, 1, 2}
 {0, 1, 3, 2}
 {0, 1, 2, 3}, так, это было для {0, 1, 2}, дальше 
 {3, 0, 2, 1}  
 {0, 3, 2, 1}
 {0, 2, 3, 1}
 {0, 2, 1, 3}, для {0, 2, 1}, дальше 
 {3, 1, 0, 2} 
   ...
 } 

 И действительно, таким образом мы вычислим все перестановки, без дублирования.  
 У нас есть все задатки для классического рекурсивного алгоритма здесь: 
 у нас есть базовый вариант задачи,
 и у нас есть способ использовать решение базовой задачи для получения решения более сложной. 

 Уже этого почти достаточно, чтобы написать правильный код, но не совсем. 
 Следующий раз на Faic я собираюсь обсудить небольшие изменения мы можем внести в набросал выезда алгоритм, 
 который добавляется небольшое количество осложнений в обмен на а элегантный отель.
