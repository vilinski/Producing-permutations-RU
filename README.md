#Получение перестановок

Одна из моих наиболее популярных статей 2010 года был мой пост 
о том, как вычислять декартово произведение любого числа последовательностей одного и того
же типа. 
То есть, у нас есть некоторые последовательности, скажем, `{10, 20, 30}` и `{200, 300, 4
00}`, и мы хотим получить последовательность всех возможных комбинаций:

```csharp
{ 
   {10, 200}, {10, 300}, {10, 400} 
   {20, 200}, {20, 300}, {20, 400}
   {30, 200}, {30, 300}, {30, 400} 
 } 

```
С этим связан вопрос, на который я не ответил: "Как получить все возможные перестановки последовательности?" Этот вопрос мы будем изучать в течение следующих нескольких эпизодов. 


 Во-первых, мы должны дать определение "перестановка". Перестановка в нашем случае является возможным изменением порядка конечной последовательности уникальных элементов.  Я не собираюсь рассматривать более сложныме перестановки. Например, как найти все упорядочения последовательности, содержащей три синих носка, один красный носок и один зеленый, мы будем считать, что все носки являются уникальными.  Давайте предположим, что последовательность, которую мы переставляем содержит N елементов `{0, 1, 2, 3, .. n - 1}`.  Как мы вскоре увидим, если мы можем переставить элементы этой последовательности, то мы можем переставлять любую последовательность из N элементов. 

 Сколько существует перестановок размера N?  Мы могли бы их перечислить и попытаться найти что-то общее.  

Очевидно, что существует только одна перестановка последовательности `{0}` , и нет никакого способа, чтобы изменить её порядок.  

Есть два варианта перестановки последовательности из двух элементов: {0, 1} и {1, 0} . 

 Их 3-х элементов?  `{0, 1, 2}, {0, 2, 1}, {1, 0, 2}, {1, 2, 0}, {2, 0, 1}, {2, 1, 0} `.  Шесть. 

 Их 4-х элементов? `{0, 1, 2, 3}, {0, 1, 3, 2}, ... ` Это уже длинно получается... 

 Давайте, вместо того чтобы их перечислять, применим математический подход . 

 Для последовательности из N элементов, существует N различных возможности выбрать первый элемент.  Этот первый элемент становится недоступным для выбора второго элемента, так что есть N-1 возможностей выбрать второй элемент, N-2 возможностей выбрать третий и так далее вплоть до N-(N-1) = 1 - единственной возможности выбрать последний элемент, она полностью предопределяется предыдущими выборами.  Умножьте всё это вместе и получим N!  - Который соответствует нашим результаты до сих пор, так как 1!  = 1, 2!  = 2, 3!  = 6. 

 Подождите, мы забыли одну последовательность: Что из себя представляют все перестановки пустой последовательности, с 0 элементами, { } ?  Очевидно, что существует только одна возможность перестановки пустой последовательности, которая тоже является пустой последовательностью.  И по соглашению, 0!  есть 1, так что теория пока в порядке.  Мы показали, что имеется n!  перестановок последовательности из N элементов. 

 Итак, как же мы теперь можем перечислить все эти перестановки?  Есть несколько способов. 
NOT COMPLETE
==========================
Допустим я собираюсь показать вам, использует рекурсию.  Как мы уже обсуждали много раз прежде, каждый рекурсивный алгоритм имеет ту же структуру: 
 Если мы находимся в тривиальном случае затем решить нетривиальную задачу и вернуться. 
 В противном случае, мы находимся в сложном случае. 
 Уменьшите комплексном случае до конечного числа более простых задач. 
 Решите более простых задач рекурсивно. 
 Если объединить их решения для решения сложной проблемы и возвращение. 

 У нас есть тривиальный случай: мы знаем, что единственная перестановка нулевой элемент последовательности является он сам. 

 Теперь предположим, что у нас в руках последовательность всех перестановок трех размеров, и мы хотим, чтобы все перестановки размером четыре.  То есть, мы имеем: 
  {
 {0, 1, 2},
 {0, 2, 1}
 {1, 0, 2},
 {1, 2, 0},
 {2, 0, 1}
 {2, 1, 0}
 } 

 Как мы можем использовать это для получения последовательности размером 4?  Ну, есть 6 перестановок в этой последовательности.  Мы знаем, что мы собираемся нужно придумать с 24 как-то.  Это дает нам интуиция, что каждый из этих 6 должны быть в состоянии генерировать еще 4 последовательностей.  А на самом деле она может: мы изменим каждой последовательности, вставив 3 перед первым элементом, перед вторым элементом, перед третьим элементом, или после третьего элемента: 
  {  
 {3, 0, 1, 2} 
 {0, 3, 1, 2}
 {0, 1, 3, 2}
 {0, 1, 2, 3}, OK, которая заботилась о {0, 1, 2}, давайте двигаться дальше 
 {3, 0, 2, 1}  
 {0, 3, 2, 1}
 {0, 2, 3, 1}
 {0, 2, 1, 3}, OK, которая заботилась о {0, 2, 1}, давайте двигаться дальше 
   {3, 1, 0, 2} 
   ...
 } 

 И действительно, мы перечислим все перестановки Таким образом, без дублирования.  У нас есть все задатки для классического рекурсивного алгоритма здесь: у нас есть базовый вариант, и у нас есть способ использовать решение в меньшей проблемой для получения решения более широкой проблемы. 

 Уже этого достаточно, чтобы написать правильный код, но мы не совсем еще. Следующий раз на Faic я собираюсь обсудить небольшие изменения мы можем внести в набросал выезда алгоритм, который добавляется небольшое количество осложнений в обмен на а элегантный отель.
